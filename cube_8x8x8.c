/*
* Code to control an 8x8x8 led cube using avr
* http://www.instructables.com/id/Led-Cube-8x8x8/
* See lisence.txt for license.
*/
#include "cube_8x8x8.h"
#include "effect.h"
#include "launch_effect.h"
#include "draw.h"
#include <util/delay.h>
#include <avr/io.h>

#define F_CPU 16000000UL



// Main loop
// the AVR enters this function at boot time
int main (void)
{

	// This function initiates IO ports, timers, interrupts and
	// serial communications
	ioinit();

	// This variable specifies which layer is currently being drawn by the
	// cube interrupt routine. We assign a value to it to make sure it's not >7.
	current_layer = 0;

	int i;

	// Boot wait
	// This function serves 3 purposes
	// 1) We delay starting up any interrupts, as drawing the cube causes a lot
	//    noise that can confuse the ISP programmer.
	// 2) Listen for button press. One button means go into rs232 mode,
	//    The other means go into autonomous mode and start doing stuff.
	// 3) Random seed. The bootwait function counts forever from 0 to 255.
	//    Whenever you press the button, this counter stops, and the number it
	//    stopped at is used as a random seed. This ensures true randomness at
	//    every boot. Without this (or some similar process) the cube would
	//    produce the same "random" sequence every time
	i = bootwait();

	// Enable interrupts
	// This starts the routine that draws the cube content
	sei();

	// Result of bootwait() is something other than 2:
	// Do awesome effects. Loop forever.
	while (1)
	{
		// Show the effects in a predefined order
		effect_stringfly2("CUBES RULE!");	
		fireworks(8,10);
		effect_filip_filop(20);
		int_ripples(200,750);
		int_sidewaves(800,40);
		// effect_cubix(40,3);
		//effect_helix(150);
		// for (i=0; i<EFFECTS_TOTAL; i++)
		// launch_effect(i);
		
		for (i=0; i<15;i++)
		launch_effect(effectsList[i]);

		// Show the effects in a random order.
		// Comment the two lines above and uncomment this
		// if you want the effects in a random order.
		// launch_effect(rand()%EFFECTS_TOTAL);
		// fireworks(10,60);
		// effect_cubix(10,4);

		// rs232();
	}

}

/*
* Multiplexer/framebuffer routine
* This function is called by an interrupt generated by timer 2.
* Every time it runs, it does the following:
* 1) Disable the output for the multiplexer array.
* 2) Turn of all layers.
* 3) Load the current layer from the cube buffer onto the
*    multiplexer array.
* 4) Enable output from the multiplexer array.
* 5) Turn on the current layer.
* 6) Increment the current_layer variable, so the next layer is
*    drawn the next time this function runs.
*/

ISR (TIMER2_COMPA_vect) {
	uint8_t i = 0;

	// all layer selects off
	PORTC = 0x00;

	// Set OE high to disable outputs before making changes
	PORTB |= (1 << OE);

	// Pull the latch low so changes don't show up yet
	PORTB &= ~(1 << LATCH_PIN);
	
	// Give it a few (milli)seconds to get ready
	// for (int j = 0; j < 25; j++) {
	// 	asm volatile ("nop");
	// }

	for (i=0; i<8; i++)
	{
		// Sends current layer to the data port one row at a time
		// cube[current_layer][i] is a byte, perfect for sending via spi
		// sendSPI(cube[layerfix[current_layer]][i]);
		sendSPI(cube[current_layer][i]);
	}
	
	// Give it a few (micro)seconds to finish up
	// for (int j = 0; j < 25; j++) {
	// 	asm volatile ("nop");
	// }

	// Latch in the changes
	PORTB |= (1 << LATCH_PIN);

	// Turn on the shift register outputs
	

	if (current_layer < 8)
	{
		PORTC = layerfix[current_layer];
		// PORTC = current_layer;
		PORTB &= ~(1 << OE);
	}

	current_layer++;

	if (current_layer > 7)
	current_layer = 0;
}

void ioinit (void)
{
	DDRB = 0B11101111;	// All output except MISO
	DDRC = 0x07;	// Layer select output

	PORTC = 0x00; // Set layer select off
	PORTB = 0x02; // Start with latch high
	PORTB |= (1 << OE); // And OE high

	// Reset any PWM configuration that the arduino may have set up automagically!
	TCCR2A = 0x00;
	TCCR2B = 0x00;

	TCCR2A |= (0x01 << WGM21); // CTC mode. clear counter on TCNT2 == OCR2A
	OCR2A = 10; // Interrupt every 25600th cpu cycle (256*100)
	TCNT2 = 0x00; // start counting at 0
	TCCR2B |= (0x01 << CS22) | (0x01 << CS21); // Start the clock with a 128 prescaler

	TIMSK2 |= (0x01 << OCIE2A);

	// Enable SPI in MSB-first mode, disable SPI
	// interrupt, and set SPI clock prescaler to 2
	SPCR |= _BV(MSTR);
	SPCR |= _BV(SPE);
	SPCR &= ~(_BV(DORD));

	// Set SPI mode
	SPCR = (SPCR & ~SPI_MODE_MASK) | 0;  // mode 0

	// Set SPI speed
	SPCR = (SPCR & ~SPI_CLOCK_MASK) | (0x04 & SPI_CLOCK_MASK);
	SPSR = (SPSR & ~SPI_2XCLOCK_MASK) | ((0x04 >> 2) & SPI_2XCLOCK_MASK);

	// Set up the ADC for reading the random seed
	ADCSRA |= (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);
	ADMUX |= (1 << REFS0) | (0 << MUX3) | (1 << MUX2) | (0 << MUX1) | (1 << MUX0) | (1 << ADLAR);
	ADCSRA |= (1 << ADEN);
	
	
	// Serial stuff
/*	UBRR0H = (BAUD_PRESCALE >> 8); // Load upper 8-bits of the baud rate value into the high byte of the UBRR register
	UBRR0L = BAUD_PRESCALE; // Load lower 8-bits of the baud rate value into the low byte of the UBRR register
		UCSR0B |= (1 << RXEN0) | (1 << TXEN0);   // Turn on the transmission and reception circuitry
			UCSR0C |= (1 << UMSEL00) | (1 << UCSZ00) | (1 << UCSZ01); // Use 8-bit character sizes
	UDR0 = 0x00; // send an empty byte to indicate powerup.
	*/

USART_Init(MYUBRR);

}

// Boot wait function
// This function does 3 things:
// 1) Delay startup of interrupt. I've had some problems with in circuit
//    serial programming when the cube was running. I guess switching all
//    those LEDs on and off generates some noise.
// 2) Set a random random seed based on the delay between boot time and
//    the time you press a button.
// 3) Select mode of operation, autonomous or rs232 controlled.
unsigned int bootwait (void)
{
	unsigned int x = 0;
	ADCSRA |= (1 << ADSC);
	while (1)
	{
		x++; // increment x by one.
		srand(ADCH); // use counter x as random seed

		delay_ms(500);
		if (x == 4)
		return x;
	}
}

void sendSPI(uint8_t _data) {
	SPDR = _data;
	while (!(SPSR & _BV(SPIF)))
	;
}


// Take input from a computer and load it onto the cube buffer
void rs232(void)
{
	int tempval;
	int x = 0;
	int y = 0;
	int escape = 0;
	// effect_test2();
	
	while (1)
	{
		// Wait until a byte has been received
		while ( !(UCSR0A & (1<<RXC0)) );

		// Load the received byte from rs232 into a buffer.
		tempval = UDR0;

		// Uncommet this to echo data back to the computer
		// for debugging purposes.
		// UDR0 = tempval;

		// Every time the cube receives a 0xff byte,
		// it goes into sync escape mode.
		// if a 0x00 byte is then received, the x and y counters
		// are reset to 0. This way the x and y counters are
		// always the same on the computer and in the cube.
		// To send an 0xff byte, you have to send it twice!

		// Go into sync escape mode
		if (tempval == 0xff)
		{
			// Wait for the next byte
			while ( !(UCSR0A & (1<<RXC0)) );
			// Get the next byte
			tempval = UDR0;

			// Sync signal is received.
			// Reset x and y counters to 0.
			if (tempval == 0x00)
			{
				x = 0;
				y = 0;
				escape = 1;
			}
			// if no 0x00 byte is received, proceed with
			// the byte we just received.
		}

		if (escape == 0)
		{
			// Load data into the current position in the buffer
			fb[x][y] = tempval;

			// Check if we have reached the limits of the buffer array.
			if (y == 7)
			{
				if (x == 7)
				{
					// All data is loaded. Reset both counters
					y = 0;
					x = 0;
					// Copy the data onto the cube.
					tmp2cube();
				} else
				{
					// A layer is loaded, reset y and increment x.
					x++;
					y = 0;
				}
			} else
			{
				// We are in the middle of loading a layer. increment y.
				y++;
			}
			
		} else
		{
			escape = 0;
		}
	}
}


void USART_Init( unsigned int ubrr)
{
	/*Set baud rate */
	UBRR0H = (unsigned char)(ubrr>>8);
	UBRR0L = (unsigned char)ubrr;
	/* Enable receiver and transmitter */
	UCSR0B = (1<<RXEN0)|(1<<TXEN0);
	/* Set frame format: 8data, 2stop bit */
	UCSR0C = (1<<USBS0)|(3<<UCSZ00);
}